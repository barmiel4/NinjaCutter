# Ninja Cutter 
## About the project
It's a physics demo that allows users to procedurally slice any convex shape repeatedly with their mouse and supports the basic physics simualation, such as applying forces, acceleration and velocity intergration.

## Demo showcase
<p align="center">
  <img src="https://github.com/user-attachments/assets/88f339d6-6726-430c-a4f4-4bfce71ec7c6" width="800"><br>
  <b>Appication of forces and shape slicing with mouse</b>
</p>

## Implementation details

### Slicing 
The slicing alorigthm is a crucial part of the engine. Slicing of any convex shape with an arbitrary number of vertices is supported, so if cut occurs, there will be at most two intersection points and two cut out pieces. To store new shapes, the two new vertex arrays are generated along with a boolean discriminator that determines to which array we are currently adding vertecies.

The steps of the algorithm are as follows:
* Add the current vertex to the active array
* Check if there is an intersection on the edge(between the current and the next vertex) with the cutting line generated by user
* If it is, add the intersection point to both arrays and switch the array
* If not, proceed to the next vertex

#### Intersection test
The test treats each edge and the cutting line as mathematical ray defined as **v(t) = v0 + t * d**, where v0 is a vertex and d is the edge that is currently tested expressed as vector. The algorithm calculates a _t_ that tells how much should we move on the edge vector to each intersection point. _t_ is expected to be in range <0; 1>. If it's beyond that, it means that the intersection point is not on the edge. 

#### Final step
If two intersection points were found, the two new rigid bodies are created and added to the array of all simulated bodies. The next step is to apply the force to the furthest intersection point. Also we want the force to be perpendicular to the cutting line, so that leter both shapes can float away in the opposite directions. The clever thing here is that the side on which each sliced piece is doesn't matter to the algorithm. The caculation uses a concept of a vector rejection, by calculating a vector from the cutting line start to the vertex of the first sliced piece and projecting it onto the cutting line. By substracting that projection from the original vector and normalizing it, gives us a unit vector perpendicual to the line, pointing to the side on which the first sliced piece is. This way we have a correctly determined force direction that can be mutiplied by a strength factor to produce force vector.
It can be applied to the first sliced piece directly or negated to push the other sliced piece in the opposite direction. 

This way each sliced piece will allways be pushed in the correct direction.

<p align="center">
  <img src="https://github.com/user-attachments/assets/b8c5a874-e18c-48aa-8a35-32be405549a8"><br>
  <b>Process of calculating the force direction</b>
</p>

### Physics simulation
The underpinnings of the physics engine resides in the rigidBody class. Each rigid body stores its physics properties: mass, linear and angular velocity, torque along with data about the polygon that will be simulated, sliced and rendered. Also, each rigid body stores its moment of inertia - for simplicity it is calculated bases on the polygons's bounding box. 

Each body can be moved with a force. Here, a **the force arm** is calculated. It's a vector from the shape's center to the force effector point. Then, the linear velocity is determined by scaling the force vector by the mass of the rigid body.
By crossing the arm and force vector, a torque can be calculated along with moment of inertia used to set the angular velocity. Then the update function moves and rotates the shape based on the velocities calculated previously.

## Tools 
Project was implemented in C++17 and uses simple library SFML-2.5.1 for keyboard event handling and shapes rendering.

## Usage

### How to run it
Project can be compiled and run via Visual Studio in either Debug or Release mode in x86 configuration. Additionally:
* Debug configuaration enables functionality such as force application to the shape nearest to the mouse coursor.
* **VIS_DEBUG** define shows the visualisation of certain debug properties, such as: which shape and vertex the mouse coursor is closest to.
* **DETAILED_DEBUG** define prints shape data and program logs to the console.
### How to play it
Hold down the **Left Mouse Button** and drag the mouse to draw a cutting line along which the shapes will be sliced. Release the mouse button once you want to cut. Use **Space** key (in debug mode) to nudge any shape with a light force to test the physics system.

## Future Improvements
The project has few areas where improvements are planned:
* Collision resolution - as the shapes can move at higher speeds where the precision is required, Continuous Collision Detection would be a great addition to the engine
* Physics calculation - for better visuals and more accurate simulation, improvements would include more robust center calculation of the sliced shapes, as well as calculating the moment of inertia specific to the shape
* System architecure - can be rewised and improved to be more flexible

## Idea origin
The project was created when I wanted to experiment with 2D graphics and phyiscs. The main inspiration was _Fruit Ninja_, a mobile game where players can slice fruits floating on the screen with the rapid finger movement thorugh the screen. 
