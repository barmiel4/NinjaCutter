# Ninja Cutter 
## About the project
It's a physics demo that allows users to procedurally slice any convex shape repeatedly with their mouse while supporting the basic physics simualation, such as applying forces, acceleration and velocity intergration

## Demo showcase
<p align="center">
  <img src="https://github.com/user-attachments/assets/88f339d6-6726-430c-a4f4-4bfce71ec7c6" width="800"><br>
  <b>Appication of forces and shape slicing with mouse</b>
</p>

## Implementation details

### Slicing 
The slicing alorigthm is the curcial part of the engine. As the engine supports slicing convex shapes, if cut occurs there will be at most two intersection points and two cut out pieces, thus two new vertex arrays are generated with the boolean that determines to which array do we currently add vertecies.
The steps of the algorithm are as follows:
* Add the current vertex to the active array
* Check if there is an intersection on the edge(between the current and the next vertex) with the cut line generated by user
* If it is, add the intersection point to both arrays and switch the array
* If not, procces to the next vertex

#### Intersection test
The test treats each edge and the cut line as mathematical ray defined as **v(t) = v0 + t * d**, where v0 is a vertex and d is the edge that is currently tested expressed as vector. The algorithm calculates a _t_ that tell how much should we move on the edge vector to each intersection point. _t_
is expected to be in range <0; 1>. If it's beyond that range, it means that the intersection point is not on the edge. 

#### Final step
If two intersection points were found, the two new rigid bodies are created and added to the array of all simulated bodies and the force is applied to the furthest intersection point, perpendicular to the cut line. The clever thing her is that, the side on which each cut piece is doesn't matter to the algorithm. The caculation uses a concept of a vector rejection, by calculating a vector from the cut line start to the vertex of the first cut piece and projecting it onto the cut line. By substracting that projection from the original vector and normalizing it, gives us a unit vector perpendicual to the line, pointing to the side on which the first cut piece is. This way we have a correctly determined force direction that can be mutiplied by a strength factor to produce force vector.
It can be applied to the first cut piece directly or negated to push the other cut piece in the opposite direction. 

<p align="center">
  <img src="https://github.com/user-attachments/assets/b8c5a874-e18c-48aa-8a35-32be405549a8"><br>
  <b>Process of force direction calculation</b>
</p>

### Physics simulation
The base of the physics engine resides in the rigidBody class. Each rigid body stores its physics properties: mass linear and angular velocity torque along with data about the polygon that will be simulated and rendered. Also, each rigid body stores its moment of inertia - for simplicity it is calculated bases on the shapes bouding box. 

Each body can be moved with a force. Here, a vector from the shape's center to the force effector point, also called **the force arm** is calculated. Then, the linear velocity is determined by scaling the force vector by the mass of the rigid body. By crossing the arm and force vector, a torque can be calculated and, along with moment of inertia used to set the angular velocity. Then the update function moves and rotates the shape based on the velocities calculated previously.

## Tools 
Project was implemented in C++17 and uses simple library SFML-2.5.1 for keyboard event handling and shapes rendering.

## Usage

### How to run it
Project can be compiled and run via Visual Studio in either Debug or Release mode in x86 configuration. Additionally:
* Debug configuaration enables functionality such as force application to the shape nearest to the mouse coursor.
* VIS_DEBUG define shows the visualisation of certain debug properties, including the which shape and vertex the mouse coursor is closest to.
* DETAILED_DEBUG define prints shape data and program logs to the console.
### How to play it
Hold down the Left Mouse Button and drag the mouse the spawn a cut line along which the shapes will be sliced. Release the mouse button once you want to cut. Also Space key can be used in debug mode to nudge any shape with a light force to test the physics system.

## Future Improvements
The project has few areas where improvements are planned:
* Collision resolution - as the shapes can move at higher speeds where the precision is required, Continuous Collision Detection would be a great addition to the engine
* Physics calculation - for better visuals and more accurate simulation, improvements would include more robust center calculation of the cut shapes as well as moment of inertia specific to the shape etc.
* System architecure - can be rewised and improved to be more flexible

## Idea origin
The project was created when I wanted to experiment with 2D graphics and phyiscs. The main inspiration was _Fruit Ninja_, a mobile game where players can slice fruits floating on the screen with the rapid finger movement thorugh the screen. 
